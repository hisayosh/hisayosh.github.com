<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hisayosh-&gt;blog</title><link>http://hisayosh.github.io/</link><description></description><atom:link href="http://hisayosh.github.io/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Sun, 05 Jan 2014 15:20:00 +0900</lastBuildDate><item><title>今更ながらの #isucon 3 参加報告 Part 2</title><link>http://hisayosh.github.io/posts/2014/01/isucon/</link><description>&lt;h3&gt;&lt;strong&gt;はじめに&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;あけましておめでとうございます。2013年に開催された&lt;a href="http://isucon.net/"&gt;isucon 3&lt;/a&gt;の参加報告です。本blogのフレームワークを&lt;a href="http://octopress.org/"&gt;Octopress&lt;/a&gt;から&lt;a href="http://docs.getpelican.com/en/3.3.0/"&gt;Pelican&lt;/a&gt;に移行する等していたため開催から2ヶ月遅れの更新となりました。...年越してしまっていますね。  &lt;/p&gt;
&lt;p&gt;さて本題です。  &lt;/p&gt;
&lt;p&gt;2011 年度、2012 年度の isucon は本戦のみの一発勝負であるのに対し 2013 年度は Amazon EC2 を利用したリモート参加者によるオンライン予選と渋谷ヒカリエの LINE 本社で開催される本戦の二部構成となっています。   &lt;/p&gt;
&lt;p&gt;我々勝浦タンタンメンチームは予選は運良く 1 位通過できたものの本戦は Fail しスコア無しという惨敗結果に終わりました。チームの方針や反省点に関してはチームメンバーの&lt;a href="https://twitter.com/sechiro"&gt;@sechiro&lt;/a&gt;、&lt;a href="https://twitter.com/qtakamitsu"&gt;@qtakamitsu&lt;/a&gt;が詳細な blog&lt;a href="#1"&gt;*1&lt;/a&gt; を書いてくれているので、来年の isucon に今回の反省を活かすためにも自分なりの視点で備忘録を書きたいと思います。   &lt;/p&gt;
&lt;p&gt;根本的に実力が不足していたことは間違いないですが、限られた力量の中で最善を尽くせたかというと、残念ながら良くない方向に振れてしまったかなと思います。「では技術面以外で不足していた点は何か？」という視点で敗因を書いていきたいと思います。    &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;敗因1 : Technology Driven&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;第一の敗因は、本戦で使う技術・方向性をお題が出る前から固めたことだと考えています。本戦でどのような特性のアプリケーション・レギュレーションになるか分からないという不確定要素がある状況で、事前に技術の方向性を決定することは、勝負の結果を運任せにすることとほぼ同義になります。  &lt;/p&gt;
&lt;p&gt;C コーダーの多い勝浦タンタンメンの場合は、それなりに書き慣れている Apache Module(mod_isucon) を準備し、本戦ではお題目アプリを一気にポーティングしベストスコアを指すという事前方針でした。&lt;a href="#2"&gt;*2&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;予選のように単一マシンで縦方向の最適化が勝負の決め手になる場合はコンピュータの資源が限られている上に、複数マシン間における一貫性や同期等を考慮する必要がないためアプリケーションスタックはある程度限定される傾向にあります。そのような前提条件においては、お題目アプリケーションのネイティブアプリケーションへのポーティング &amp;amp; チューニングは、CPU bound である場合に LL 系言語と実行速度の差別化を図るという観点で有効に作用する可能性が相応にあります。  &lt;/p&gt;
&lt;p&gt;しかし本戦は 5 台のサーバを利用した分散システムです。従って、システム全体で最適なパフォーマンスを発揮するためのアーキテクチャ検討の重要性がより高くなり、垂直方向にアプリケーションのみを高速化するメリットが相対的に小さくなります。&lt;a href="*3"&gt;#3&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;結果論にはなりますが、もう少し丁寧に戦略を練っていれば事前に検討できたことだと思います。isucon 対策合宿や isucon hackathon 等を含め、今まで単一マシンのみで対策・検討してきたことが、想像力や思考を曇らせたことに寄与していると思います。&lt;/p&gt;
&lt;p&gt;当日レギュレーションが発表された段階で、おおよそ mod_isucon で対応していては間に合わない上に性能向上のアプローチとして間違っていることが判明し、チームで方針を決定する上で冷静さに悪影響が出たかなと思います。  &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;敗因 2 : 当日の戦略ミス&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;第二の敗因は、@sechiro が &lt;a href="http://sechiro.hatenablog.com/entry/2013/12/17/%E4%BB%8A%E6%9B%B4%E3%81%AA%E3%81%8C%E3%82%89%E3%81%AE_%23isucon_3_%E5%8F%82%E5%8A%A0%E5%A0%B1%E5%91%8A%EF%BC%9A%E3%80%8Cisucon%E3%81%AB%E5%8B%9D%E3%81%A6%E3%82%8B%E9%8A%80%E3%81%AE%E5%BC%BE%E4%B8%B8"&gt;blog&lt;/a&gt; で「制限事項の理解と適切なアーキテクチャの選定ミス」という形でまとめてくれている部分ではあるのですが、自分の言葉でも書いておきたいと思います。isucon 本戦の競技時間は 7 時間しかありません。「時間」や「チームの能力」という限られた資源やレギュレーションから発生し得るボトルネック考察をもとに、実装できる最善の設計を可能な限り早く見極め、ひとつひとつ丁寧に実装していくことが大切です。しかし、当日はこの認識が不足していました。  &lt;/p&gt;
&lt;p&gt;レギュレーションの意識という観点では、勝浦タンタンメンでも、構成上 I/O bound になる設問であると当然早期に判断してはいました。しかし、フロントの帯域がサーバ一台あたり100 Mbps(12.5 MByte per sec) に制限されているという重要な前提を軽視したことにより、具体的な実装に落としこんでいく上で最も重要である「いかにフロントのネットワーク帯域を使い潰すか」という視点を失うことになりました。  &lt;/p&gt;
&lt;p&gt;また、時間や能力等を元に実現可能なアーキテクチャを検討するという観点では、時間的・能力的に制限時間に間に合わないリスクを伴う理想的な実装を追い求めた結果、最終計測に間に合わずに Fail するという結果になりました。チームメンバーは普段異なる会社で働き、肩を並べてコーディングした時間が少ないという点も影響したとは思います。しかし、それは最初から分かっていることなので、事前にもう少し踏み込んで、各個人ができること・できないことを共有し、戦略策定時に参考にする必要があったかなと反省しています。   &lt;/p&gt;
&lt;p&gt;isucon 予選のレギュレーションは Fail に対する罰則も軽く、ある程度は力技で通せる面もありましたが、本戦では Fail=即死 ですので一つでも問題があると命取りになります。チーム内の協調力や検討力、システムの安定性をより強く問う良問だったと思います。  &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;最後に&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;isucon 3 を通じて技術的に大変多くのことを学ばせて頂きましたし、上記のような異種混合チームで極めて限られた時間の中で物事を進めていく際の難しさについても学ばせて頂きました。主催者チームの方、スポンサー企業様、関係者の皆様には深く感謝しています。  &lt;/p&gt;
&lt;p&gt;最後に、isucon への当事者としての参加は、チームの中で切磋琢磨できるだけではなく、他チームの技術的・戦略的な問題解決方法を自ずと深く勉強することになり、非常に得るものが多いです。次回以降どのような形式で開催頂けるのか分かりませんが、 isucon 3 に参加しなかったエンジニアの方々には次回への参加を強くオススメします。  &lt;/p&gt;
&lt;p&gt;&lt;a name="1"&gt;&lt;/a&gt; *1 : &lt;a href="http://sechiro.hatenablog.com/entry/2013/12/17/%E4%BB%8A%E6%9B%B4%E3%81%AA%E3%81%8C%E3%82%89%E3%81%AE_%23isucon_3_%E5%8F%82%E5%8A%A0%E5%A0%B1%E5%91%8A%EF%BC%9A%E3%80%8Cisucon%E3%81%AB%E5%8B%9D%E3%81%A6%E3%82%8B%E9%8A%80%E3%81%AE%E5%BC%BE%E4%B8%B8"&gt;今更ながらの #isucon 3 参加報告：「isuconに勝てる銀の弾丸などなかった」&lt;/a&gt;
&lt;a href="http://qtkmz.jp/blog/2013/11/13/isucon3.html"&gt;isucon 3 に参加しました&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="2"&gt;&lt;/a&gt; *2 : templateやDB接続部等を含めて事前に準備をしてくれた @qtakamitsu に感謝&lt;/p&gt;
&lt;p&gt;&lt;a name="3"&gt;&lt;/a&gt; *3 : 一方で優勝チームのように、どのようなお題が出たとしてもおおよそ必要になると思われる準備を事前に行うことは、時間制限のあるisuconにおいて極めて有効だと思います。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Hisayoshi Tamaki</dc:creator><pubDate>Sun, 05 Jan 2014 15:20:00 +0900</pubDate><guid>tag:hisayosh.github.io,2014-01-05:posts/2014/01/isucon/</guid><category>isucon</category></item><item><title>tsc_checker - 新208.5日問題簡易チェックツール</title><link>http://hisayosh.github.io/posts/2013/12/tsc_checker/</link><description>&lt;p&gt;以前情報公開した&lt;a href="http://hisayosh.github.io/posts/2013/12/208days-problem/"&gt;新 208.5 日問題&lt;/a&gt;向けに、現在の TSC 値出力や numeric overflow 警告を行うツールを作成しました。  &lt;/p&gt;
&lt;p&gt;「今動いているサーバは大丈夫なのか？」という疑問を解決するためのツールです。GCC Inline Assembler を含め Linux Kernel 内の新 208.5 日問題ロジックとほぼ同等の処理を行います。&lt;a href="http://hisayosh.github.io/posts/2013/12/208days-problem/"&gt;記事&lt;/a&gt;にも書きましたが、&lt;strong&gt;本問題は旧 208.5 日問題とは異なり、 uptime 結果を確認することによって問題の有無を判断することが出来ません。再起動を行っても TSC 値がリセットされないことが問題の発生要因であるためです。ご注意ください。&lt;/strong&gt;&lt;a href="#1"&gt;*1&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;a href="https://github.com/hisayosh/tsc_checker"&gt;https://github.com/hisayosh/tsc_checker&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;従来のオペレーション（再起動）による TSC 値の蓄積状況を確認する&lt;/li&gt;
&lt;li&gt;仮の CPU クロック周波数を基に現在の numeric overflow の発生可能性を定量的に確認する&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;出力内容&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;現在の CPU 内の TSC 値&lt;/li&gt;
&lt;li&gt;引数で取得した CPU クロック周波数を元に算出した SC 値&lt;/li&gt;
&lt;li&gt;不具合を伴うロジックにより発生する pico sec order の 64 bit 変数値&lt;/li&gt;
&lt;li&gt;64 bit 変数の上限値&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;利用方法&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;tsc_checker の実行に必要な要素は、tsc_checker 実行環境の CPU クロック周波数のみです。以下の 2 ステップで実行します。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;1. tsc_checker 実行サーバの CPU クロック周波数の取得&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Intel Xeon E5 プロセッサーファミリーであれば、tsc_constant により TSC は CPU クロック周波数の動的変動の影響を受けません。コマンドラインから以下のコマンドを実行して該当 CPU の最大クロック周波数を取得します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;&lt;strong&gt;2. tsc_checker の実行&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;tsc_checkerを実行します。「-f」オプションの引数として「1.」で取得したクロック周波数を指定します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./tsc_checker -f 2794000
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;計算結果 : 通常時&lt;/strong&gt;&lt;a href="#2"&gt;*2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;TSC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1476354219900&lt;/span&gt;
&lt;span class="n"&gt;SC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;         &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;366&lt;/span&gt;
&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;    &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;540345644483400&lt;/span&gt;
&lt;span class="n"&gt;threashold&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;18446744073709551615&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;計算結果 : numeric overflow 発生時&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;TSC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;295504282125&lt;/span&gt;
&lt;span class="n"&gt;SC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;         &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;366&lt;/span&gt;
&lt;span class="o"&gt;***&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="o"&gt;***&lt;/span&gt;
&lt;span class="n"&gt;there&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;possibility&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;numeric&lt;/span&gt; &lt;span class="n"&gt;overflow&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;startup&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;taken&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;tsc_checker の仕組み&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;仕組みは単純です。まず、 TSC 値を Inline Assembler により取得します。具体的には、CPU に対し rdtsc ( read time stamp counter ) 命令を実行し、結果の上位 32 bit を EDX register、下位 32 bit を EAX register 経由で、それぞれ uint32_t 型の変数に格納します。そして「32 bit 左に shift した上位 bit 変数」と「下位 bit 変数」を OR 演算することで、uint64_t 型の変数にTSC 値を格納します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="nf"&gt;get_tsc&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;asm&lt;/span&gt; &lt;span class="k"&gt;volatile&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rdtsc&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;=a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;=d&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;次に、SC ( SCale ) の算出を行います。こちらも Linux Kernel と同一のロジックになっています。1000000 &lt;a href="#3"&gt;*3&lt;/a&gt; に対して 10 bit &lt;a href="#4"&gt;*4&lt;/a&gt; 分の左 shift を行った数値をキロヘルツ単位のクロック周波数で除算することで SC を算出します。最後行の tsc * scale が numeric overflow 発生原因となる演算です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;tsc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_tsc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000000&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tsc&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考までに、Linux Kernel では以下のマクロ演算で tsc * scale の計算を行うことにより numeric overflow の発生を抑止しています。tsc_checker の &lt;a href="https://github.com/hisayosh/tsc_checker/blob/master/tsc_checker.h"&gt;header file&lt;/a&gt; にマクロを追加していますので興味のある方はどうぞ。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* from linux kernel (/include/linux/kernel.h b/include/linux/kernel.h)&lt;/span&gt;
&lt;span class="cm"&gt; * Multiplies an integer by a fraction, while avoiding unnecessary&lt;/span&gt;
&lt;span class="cm"&gt; * overflow or loss of precision.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="cp"&gt;#define mult_frac(x, numer, denom)(                        \&lt;/span&gt;
&lt;span class="cp"&gt;{                                                          \&lt;/span&gt;
&lt;span class="cp"&gt;    typeof(x) quot = (x) / (denom);                        \&lt;/span&gt;
&lt;span class="cp"&gt;    typeof(x) rem  = (x) % (denom);                        \&lt;/span&gt;
&lt;span class="cp"&gt;    (quot * (numer)) + ((rem * (numer)) / (denom));        \&lt;/span&gt;
&lt;span class="cp"&gt;}                                                          \&lt;/span&gt;
&lt;span class="cp"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;tsc_checker 内でも以下のコードにより動作します。（91行目のコメントアウトを参照）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mult_frac&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1UL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a name="1"&gt;&lt;/a&gt; *1 : はてブや Twitter で誤解されている方がいらっしゃったので念の為にフォローします&lt;br /&gt;
&lt;a name="2"&gt;&lt;/a&gt; *2 : TSC は常に増加し続けるため、本ツール実行時点で numeric overflow が発生しない場合も、その後の再起動時に問題が発生する可能性があります。あくまで TSC 蓄積値の確認や現在の演算結果の目安を確認するツールとしてご利用ください&lt;br /&gt;
&lt;a name="3"&gt;&lt;/a&gt; *3 : nano sec per micro sec 値&lt;br /&gt;
&lt;a name="4"&gt;&lt;/a&gt; *4 : scale factor 値&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Hisayoshi Tamaki</dc:creator><pubDate>Tue, 31 Dec 2013 12:00:00 +0900</pubDate><guid>tag:hisayosh.github.io,2013-12-31:posts/2013/12/tsc_checker/</guid><category>Linux</category><category>Tool</category></item><item><title>新208.5日問題 - Systems with Intel® Xeon® Processor E5 hung after upgrade of Red Hat Enterprise Linux 6</title><link>http://hisayosh.github.io/posts/2013/12/208days-problem/</link><description>&lt;p&gt;Linux の連続稼働時間が 208.5 日を過ぎた段階で突如 Kernel Panic を引き起こすという過激な挙動で2011年の年の瀬に話題となった "旧208.5日問題" ですが、あれから二年が経った今、Linux Kernel 内の bug と Intel Xeon CPU の bug の合わせ技により&lt;strong&gt;再度類似の不具合が発生することが分かっています。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;旧 208.5 日問題の発生原理に関しては以下の blog が参考になります。&lt;br /&gt;
&lt;a href="http://kenichiokuyama.blogspot.jp/2011/12/schedclock-overflow-after-2085-days-in.html"&gt;okkyの銀河制圧奇譚 : sched_clock() overflow after 208.5 days in Linux Kernel&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;追記(2014/1/4)&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;新208.5日問題の簡易チェックツールを作成しました。よろしければお使い下さい。 &lt;/p&gt;
&lt;p&gt;&lt;a href="http://hisayosh.github.io/posts/2013/12/tsc_checker/"&gt;tsc_checker - 新208.5日問題簡易チェックツール&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;影響範囲&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;旧 208.5 日問題の対策パッチがあたっている Linux Kernel であっても、本 208.5 日問題は異なるロジックにより発生するため、&lt;strong&gt;影響を受けます。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red Hat Enterprise Linux 6.2, 6.3, and 6.4 (kernel 2.6.32-220, 2.6.32-279, and 2.6.32-358 series)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;不具合発生条件&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;Intel Xeon E5 シリーズのプロセッサーを利用している&lt;/li&gt;
&lt;li&gt;上記影響範囲に記述した Linux Kernel のうち、修正パッチが当たっていない（これらのバージョンのうち現在稼働中の RHEL 及び RHEL 系サーバはほとんどが該当すると思います。）&lt;/li&gt;
&lt;li&gt;最後に cold reboot を行ってから 208.5 日以上の時間が経過している状態で、再起動を行う&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;結論&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;不具合対象の環境は一時的な運用の見直しが必要です。サーバ再起動は cold reboot にしましょう&lt;/li&gt;
&lt;li&gt;根本解決には、対策パッチをあてるか、kernel code を修正してリビルドしたものを組み込みましょう&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;※ RHEL では kernel-2.6.32-220.45.1.el6 (6.2), kernel-2.6.32-279.37.2.el6 (6.3), kernel-2.6.32-358.23.2.el6 (6.4), kernel-2.6.32-431.el6 (6.5) で修正されているようです。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;旧 208.5 日問題のおさらい&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;旧 208.5 日問題は以下のインライン関数が原因となり発生します。CPU 内の TSC (Time Stamp Counter) の値を Linux が nano sec order の clock として利用するためのロジックです。CYCNS_SCALE_FACTOR は整数の 10 を表します。&lt;/p&gt;
&lt;p&gt;linux-2.6.32-220(/arch/x86/include/asm/timer.h)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;__cycles_2_ns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;cyc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;smp_processor_id&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;cyc&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ご覧の通り、TSC の値を TSC * SC &amp;gt;&amp;gt; 10 することで 64 bit 変数に nano sec を代入しようとしているので、10 bit shift が行われる前の段階では pico sec order の演算を行うことになります。pico sec order の 1 秒を表現するためには、約 40 bit の空間が必要となります。変数が 64 bit であるため、 1 秒以上の表現のためには残り約 24 bit 程しかなく、208.5日問題における 208.5 日とは、この約 24 bit で表現できる日数の上限を表したものになっています。（この日数を超えると overflow が発生します。）&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;新 208.5 日問題の解説&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Linux Kernel を起動する際、各種初期化処理を行う start_kernel()内 で x86_late_time_init() という関数が呼び出されます。&lt;/p&gt;
&lt;p&gt;linux-2.6.32.358(/arch/x86/kernel/time.c)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;x86_late_time_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;x86_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timer_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;tsc_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;このうち、tsc_init() の中で、cyc2ns_offset の初期化を行います。この初期化処理は、旧 208.5 日問題と同一のロジックを経由します。Linux の起動時には、 CPU の仕様として TSC がリセットされるはずであり、Linux 起動プロセスの初期段階である本関数がコールされる時点で TSC が 208.5 日に到達しているはずがなく、優先度の低い問題として扱われていたのだと思います。&lt;/p&gt;
&lt;p&gt;linux-2.6.32-358(/arch/x86/kernel/tsc.c)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set_cyc2ns_scale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;tsc_now&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ns_now&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;local_irq_save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;sched_clock_idle_sleep_event&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;rdtscll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc_now&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ns_now&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__cycles_2_ns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc_now&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSEC_PER_MSEC&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ns_now&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc_now&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;sched_clock_idle_wakeup_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;local_irq_restore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;しかし、時を同じくして、Intel Xeon Processor E5 Family は以下の不具合を抱えていました。本来リセットされるはずの TSC の値が、 Warm Reset (通常の再起動)時に初期化されないという不具合です。サーバの電源断を経由しない限り、 E5 Family Processor の TSC の値は保持され続けます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BT81. X X X No Fix TSC is Not Affected by Warm Reset&lt;br /&gt;
&lt;a href="http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf"&gt;Intel® Xeon® Processor E5 Family&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;つまり、新 208.5 日問題は、&lt;strong&gt;最後に電源停止を行ってから208.5日程度経過した段階で、再起動をした際に前述の初期化処理において offset 計算が overflow することで顕在化します。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;旧 208.5 日問題とは異なり、&lt;strong&gt;稼働中の OS では発生しませんが、再起動時に突然ハング状態になるため、対策パッチをあてるか、tsc.c &amp;amp; kernel.h を自前で修正してリビルドするか、運用プロセスを一時的に変更する必要があると思います。&lt;/strong&gt;kexec時も同様の問題が起きるはずですので、ご注意ください。&lt;/p&gt;
&lt;p&gt;記事に間違いや不明な点がありましたら、ご指摘下さい。&lt;/p&gt;
&lt;h3&gt;参考URL&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://access.redhat.com/site/solutions/433883"&gt;Red Hat : Systems with Intel® Xeon® Processor E5 hung after upgrade of Red Hat Enterprise Linux 6&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://kernel.opensuse.org/cgit/kernel/commit/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1"&gt;OpenSUSE : sched/x86: Fix overflow in cyc2ns_offset&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Hisayoshi Tamaki</dc:creator><pubDate>Tue, 24 Dec 2013 12:25:00 +0900</pubDate><guid>tag:hisayosh.github.io,2013-12-24:posts/2013/12/208days-problem/</guid><category>Linux</category><category>Bug</category></item><item><title>Identity Conferene 15</title><link>http://hisayosh.github.io/posts/2013/02/idcon-15/</link><description>&lt;p&gt;Identity Conference 15(#idcon) に参加してきました。&lt;br /&gt;
 非常に勉強になったので今後も参加できればなぁと思うと同時に&lt;br /&gt;
 SSO/IDM製品の開発に携わった経験がありながら初参加という状況で少し反省。  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://idcon.doorkeeper.jp/events/2448"&gt;#idcon 15th&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://togetter.com/li/448517"&gt;Togetther&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;Yahoo! JAPANのOAuth/OpenIDに代わる新しい認証認可機能 -YConnect-&lt;/h2&gt;
&lt;p&gt;ヤフー株式会社 河内 俊介 氏  &lt;/p&gt;
&lt;h3&gt;YConnectとは？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OAuth2.0準拠 / OpenID Connectをサポートの Yahoo!&lt;br /&gt;
    の新認証認可システム  &lt;/li&gt;
&lt;li&gt;Yahoo! でログインが可能  &lt;/li&gt;
&lt;li&gt;ユーザの一部属性情報の連携が可能  &lt;/li&gt;
&lt;li&gt;OAuth1.0 に比べて RP の実装が容易  &lt;/li&gt;
&lt;li&gt;2012年末　YConnect 設計開始  &lt;/li&gt;
&lt;li&gt;2012年9月中旬　パートナー向け公開開始  &lt;/li&gt;
&lt;li&gt;現在　公開中  &lt;/li&gt;
&lt;li&gt;対応Authorization Grant@OAuth2.0&lt;br /&gt;
     Authorization Code&lt;br /&gt;
     Implicit  &lt;/li&gt;
&lt;li&gt;対応Profile@OpenID Connect&lt;br /&gt;
     Basic Client Profile&lt;br /&gt;
     Implicit Client Profile  &lt;/li&gt;
&lt;li&gt;100サイト以上、50以上の企業に提供 毎日新聞社、GREE等等  &lt;/li&gt;
&lt;li&gt;社内アプリには続々対応中  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;用途の紹介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Yahooウォレットと連携することで決済システムを簡単に実装  &lt;/li&gt;
&lt;li&gt;属性情報の連携(ユーザ識別子、氏名、生年月日、ロケール情報、メールアドレス等等)&lt;br /&gt;
     プレミアム企業には更に多くの属性情報を開示している  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;導入構成図事例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Authorization Code 利用例  &lt;/li&gt;
&lt;li&gt;Implicit 利用例&lt;br /&gt;
     シーケンスの紹介  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;裏話&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OAuth1.0やBBAuthはYahoo!incのローカライズだった  &lt;/li&gt;
&lt;li&gt;ブラックボックスのため、メンテナンス工数が大変&lt;br /&gt;
     -&amp;gt; YConnectはフルスクラッチで開発することによりこの問題を解決  &lt;/li&gt;
&lt;li&gt;全WebAPIのSSL化を行う必要があった&lt;br /&gt;
     -&amp;gt; ワイルドカードの証明書で対応  &lt;/li&gt;
&lt;li&gt;仕様理解を深めるため、RFCの翻訳業務をPJで行った  &lt;/li&gt;
&lt;li&gt;Apple Store の reject 事例&lt;br /&gt;
    ブラウザを開いたタイミングでリンクがあると、課金の可能性を指定されrejectされた&lt;br /&gt;
     -&amp;gt; リンクを省くことで解決&lt;br /&gt;
     アプリケーションからsafariを使用してloginしたらrejectされた&lt;br /&gt;
    ログインしないと使えないようなアプリケーションはrejectされる可能性がある&lt;br /&gt;
     -&amp;gt; 解決策は見つかっていない  &lt;/li&gt;
&lt;li&gt;認証PF一覧&lt;br /&gt;
     用途によって認証PFが分散し、ユーザ識別子も分散していた&lt;br /&gt;
     　OAuth1.0 / Open ID2.0 / SSO 等  &lt;br /&gt;
     　-&amp;gt; YConnectでは上記全てを解決している  &lt;/li&gt;
&lt;li&gt;以下の機能拡張を検討中  &lt;br /&gt;
     PPID  &lt;br /&gt;
     OTP対応を検討中  &lt;br /&gt;
     シングルログアウト(Session Management)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q. カスタムURIスキーマが被ってしまった場合のセキュリティリスクは？  &lt;br /&gt;
 A. Yahoo!が提供しているアプリは他社のアプリと被らないようにしている。  &lt;br /&gt;
 攻撃者がいた場合、技術的には被らせることは可能。今後の課題として扱う。  &lt;/p&gt;
&lt;h2&gt;「Andouroid Android OSのカスタマイズによるアプリ間統合認証の実現」&lt;/h2&gt;
&lt;p&gt;ヤフー株式会社 安藤 義裕 氏  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android OS layor からアタッチ  &lt;/li&gt;
&lt;li&gt;個人(趣味)で開発  &lt;/li&gt;
&lt;li&gt;デモンストレーション&lt;br /&gt;
     Yahoo!のアプリ二種類を使い、一方のアプリにログインすると&lt;br /&gt;
     もう一方で認証が必要なくなる仕組みをデモ  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1. Yahoo!メールアプリの起動&lt;br /&gt;
 　　未ログイン状態&lt;br /&gt;
 　　アプリ終了&lt;br /&gt;
 　2. Yahoo!ブラウザの起動&lt;br /&gt;
 　　メールページを開く&lt;br /&gt;
 　　未ログイン状態  &lt;br /&gt;
 　　UID/PWD入力  &lt;br /&gt;
 　　ログイン成功、コンテンツ確認  &lt;br /&gt;
 　　アプリ終了&lt;br /&gt;
 　3. Yahoo!メールアプリの起動&lt;br /&gt;
 　　ログイン状態を維持(SSO成功)  &lt;/p&gt;
&lt;h3&gt;改修内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;WebKit(OSとアプリの中間レイヤー)の改造  &lt;/li&gt;
&lt;li&gt;ログイン画面を開く前にトークン(ストレージ)に問い合わせる仕組み  &lt;/li&gt;
&lt;li&gt;トークンはアプリケーション間で共有している  &lt;/li&gt;
&lt;li&gt;AndroidはアプリケーションごとにLinux UIDが割り当てられている  &lt;/li&gt;
&lt;li&gt;アプリが使用する Android 内の database file 等は上記の UID/GID&lt;br /&gt;
    により 660 の permission を付与し、 ACL を行っている  &lt;/li&gt;
&lt;li&gt;あんどうろいどは上記の database file&lt;br /&gt;
    に対し、独自user(yahoo)のアクセスを追加  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Androidのデータ共有の方法&lt;br /&gt;
     Content Provide&lt;br /&gt;
     　カレンダー、データ帳を他のアプリに提供&lt;br /&gt;
     Intent&lt;br /&gt;
     　アプリ間のデータのやりとり&lt;br /&gt;
     Shared Preference&lt;br /&gt;
     　テキスト等小さなデータを保存する。アプリ間の共有可能&lt;br /&gt;
     Shared ID  &lt;/p&gt;
&lt;p&gt;Play!Storeにuploadする際に、証明書を作成する。同じ証明書を使用していれば複数のapplicationで同じUIDを降ることができる    &lt;/p&gt;
&lt;p&gt;信頼できる大企業により同一の証明書を使用しアプリ間で情報連携を行うようにすれば、従来と異なるマーケットを開拓できるのでは&lt;br /&gt;
 その他(SQLite, Local File, Internet(Cloud))  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;デバイス時代のID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OSを握ってカスタマイズができる立場は非常に強力と感じている  &lt;/li&gt;
&lt;li&gt;Apple, Google&lt;br /&gt;
    をみてわかるように、OSベンダーであるからこそ出来ることは多い  &lt;/li&gt;
&lt;li&gt;やりたいこと、センシティブな情報の共有は、OSを握っているか否かで自由度がかなり変わる  &lt;/li&gt;
&lt;li&gt;デバイスの時代になると、デバイスのIDとWebのIDの境目は今後薄れていくと考えている  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q.　パッケージ名でYahoo!のアプリであることを判別している(模造可能、プロトタイプ版のため)&lt;br /&gt;
A.　アプリケーションにsignatureを付けることで正当性を確認する等の対応になると推測している  &lt;/p&gt;
&lt;p&gt;Q.　ストレージで何を共有していたか&lt;br /&gt;
A.　Cookie。本来はトークンになるべきところ。 &lt;/p&gt;
&lt;h2&gt;C向けサービスで2要素認証を普及させるためにできること&lt;/h2&gt;
&lt;p&gt;株式会社ミクシィ 伊東 諒 氏&lt;br /&gt;
&lt;a href="http://www.slideshare.net/ritou/idcon-15th-ritou-2factor-auth"&gt;Slide&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;現状と課題&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C向けサービスにおける2要素認証の現状 &lt;/li&gt;
&lt;li&gt;金融系、ゲーム系などでは以前から普及 &lt;/li&gt;
&lt;li&gt;ユーザ数の多いサービスも実装  &lt;/li&gt;
&lt;li&gt;ワンタイムパスワードが実装方法として流行  &lt;/li&gt;
&lt;li&gt;ID/PWD認証 + αをオプションで提供  &lt;/li&gt;
&lt;li&gt;脆弱性や課題については黙認状態  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;普及への課題&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ついてこれないユーザー&lt;br /&gt;
     サービスごとの設定は面倒  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;導入しにくいプロトコルの存在&lt;br /&gt;
     POP/IMAP/SMTP, XMPP, … &lt;br /&gt;
     認証とリソースアクセスの強い結びつき  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解決策&lt;br /&gt;
     Yahoo! Google Facebook 等に OpenID Connect で Rely する&lt;br /&gt;
     信頼あるプロバイダの認証強度をそのまま利用できることがメリット  &lt;/p&gt;
&lt;p&gt;認証とリソースアクセスの強い結びつきに対し、アクセストークンを利用して分離することで対応  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenID Providerがやるべきこと&lt;br /&gt;
     認証強度の見える化&lt;br /&gt;
     　RPからみて、OPがどのような認証をするのかを把握できることが大切 
     対応する認証強度を開示&lt;br /&gt;
     認証したユーザの認証強度を提供&lt;br /&gt;
     求められる認証強度をRPに指定させる  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Relying Partyがやるべきこと&lt;br /&gt;
     自らのサービス・ユーザアクションに求められる認証強度を意識する 
     適切なタイミング、強度で再認証を要求する  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;残る課題&lt;br /&gt;
     2要素認証を採用しないOPはG&lt;br /&gt;
     1 USER per 1 OP の風潮&lt;br /&gt;
     -&amp;gt; ID/PW + αは組み合わせにくい?  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;追加認証に特化した認証プロバイダ&lt;br /&gt;
     RP側が既存OPとの組み合わせ&lt;br /&gt;
     Trustが重要&lt;br /&gt;
     　B向けに実績のあるサービスの進出&lt;br /&gt;
     物理デバイス、生体認証などの可能性  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;まとめ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最大の課題は”めんどくさい”と思わせるユーザビリティ  &lt;/li&gt;
&lt;li&gt;OpenID Connect は重要  &lt;/li&gt;
&lt;li&gt;経済合理性は別として追加認証に特化した認証プロバイダは有用かも  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;実際に追加認証に対応したプロバイダを作成してみた - SecondAuth -&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;メールアドレスがあれば登録可能  &lt;/li&gt;
&lt;li&gt;OTP 認証のみ実装  &lt;/li&gt;
&lt;li&gt;OpenID Connect OP  &lt;/li&gt;
&lt;li&gt;YConnect, Google, Faceboo  k
    から受け取った確認済みメールアドレスを利用  &lt;/li&gt;
&lt;li&gt;OTP 認証には Google Authenticator を利用(Server側の処理)  &lt;/li&gt;
&lt;li&gt;ユーザ単位に Secret 作成  &lt;/li&gt;
&lt;li&gt;設定用の QR コード生成  &lt;/li&gt;
&lt;li&gt;otpauth://totp/(mailaddress)  &lt;/li&gt;
&lt;li&gt;secret=(base43_encoded_otp_secret)  &lt;/li&gt;
&lt;li&gt;ユーザはアプリをインストールし、QRコードを読み取るだけ  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;リモートログアウト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;現在アクティブなセッションを一元管理  &lt;/li&gt;
&lt;li&gt;手元で別の端末をログアウト可能  &lt;/li&gt;
&lt;li&gt;Facebook, Googleが実装  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OpenID Connect Session Management&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OPのログアウトをRPから検知するための仕様  &lt;/li&gt;
&lt;li&gt;AuthZ Response にセッション識別子  &lt;/li&gt;
&lt;li&gt;iframe + postMessageを送り続ける  &lt;/li&gt;
&lt;li&gt;OPのログアウトをRPから検知し、他のRPのセッションも終わらせる等  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;#idcon mini のお知らせ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;もっと技術的な話をしたい人向けに #idcon mini を計画している &lt;/li&gt;
&lt;li&gt;少人数、USTなし  &lt;/li&gt;
&lt;li&gt;アンカンファレンスもどき  &lt;/li&gt;
&lt;li&gt;技術屋が気になることをじっくりと話せる場  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;パネルディスカッション「スマデバ時代ぼくらは幾つパスワードを使うのか 」※USTなし&lt;/h2&gt;
&lt;p&gt;ヤフー株式会社 セントラルサービスカンパニー 技術調査室 室長 楠 正憲 氏&lt;br /&gt;
 米国・OpenID Foundation 理事長 崎村 夏彦 氏&lt;br /&gt;
 セコム株式会社 IS研究所 松本 泰 氏&lt;br /&gt;
 OpenID Foundation Japan 事務局長代行 高橋 伸和 氏&lt;br /&gt;
 独立行政法人 情報処理推進機構 神田 雅透 氏  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;パスワードはどのくらい前からあるか&lt;br /&gt;
     1961年頃らしい。IBMのメインフレーム。&lt;br /&gt;
     一昨年がパスワード誕生50年  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSLが安全であるという土台の上に認証基盤を考えてきた&lt;br /&gt;
     2011年頃からきわどい状況になっている&lt;br /&gt;
     従来の認証基盤を維持していけるのかを考えていかないといけない時期  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL/PKIはなぜ危機に陥ったのか 　 本セッションに興味があれば、PKI DAY&lt;br /&gt;
    2012から資料を取得  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jnsa.org/seminar/pki-day/2012/data/PM01_kanda.pdf"&gt;サイバー攻撃ツールとしての公開鍵証明書の役割&lt;/a&gt;&lt;br /&gt;
 (個人的に必見の資料だと思います。)  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ネットの信頼性は技術、制度・運用、実装、ユーザリテラシの4点から担保されている  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ルートCAはPKIのTrust Anchor  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開鍵証明書が悪用されるのはどんなとき?&lt;br /&gt;
     ハッキングの問題&lt;br /&gt;
     　登録局の検証ミス&lt;br /&gt;
     　認証局への不正アクセス&lt;br /&gt;
     暗号技術の問題&lt;br /&gt;
     　計算量により秘密鍵を割り出す(公開鍵暗号の根本的な問題)  &lt;/p&gt;
&lt;p&gt;真正な公開鍵証明書と区別ができない不正な証明書を計算機により偽造(ハッシュ関数の問題)&lt;br /&gt;
 運用の問題&lt;br /&gt;
 　秘密鍵の流出&lt;br /&gt;
 　意図せず秘密鍵を共有  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DigiNotar のケース(PKIの危機を招いた事例)&lt;br /&gt;
     不正SSLサーバ証明書がCA機能を乗っ取られて発行 &lt;/p&gt;
&lt;p&gt;EV-SSLサーバ証明書発酵用CAを含め、少なくとも6つのCA(疑いを含めると30個以上のCA)に不正侵入され、不正SSLサーバ証明証を発行  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ルートCAとしてはあまりにも重大な失態が相次ぐ  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件報道されるまでの5週間、事実を隠蔽し続けた&lt;br /&gt;
     2011年6月17日攻撃が始まっていたことを把握  &lt;/p&gt;
&lt;p&gt;2011年7月19日以降、短期間に不正SSLサーバ証明書の発行・失効処理が繰り返されていたにも関わらず、根本的な対策を取らなかった&lt;br /&gt;
 2011年7月28日イランにおけるで不正SSLサーバ証明書の悪用を把握&lt;br /&gt;
 OSやブラウザベンダーにも通知をしなかった&lt;br /&gt;
-   主要ブラウザベンダーの対処&lt;br /&gt;
 DigiNotar のルート証明書を削除&lt;br /&gt;
-   DigiNotar は破産手続き開始&lt;br /&gt;
-   証明書を使うのを意識しないのはなぜ？&lt;br /&gt;
実際にはブラウザやアプリケーションが自動検証する&lt;br /&gt;
 登録されている「信頼できる認証局証明書」をベースに判定&lt;br /&gt;
 設定次第でリアルタイム検証も可能&lt;br /&gt;
 最もリテラシの低い人にあわせるとこうなってしまう、という典型  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以後オフレコ部分が多かったため、割愛します。&lt;br /&gt;
 記述内容の間違い等がありましたら指摘頂けますと助かります。&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Hisayoshi Tamaki</dc:creator><pubDate>Sun, 03 Feb 2013 19:19:00 +0900</pubDate><guid>tag:hisayosh.github.io,2013-02-03:posts/2013/02/idcon-15/</guid><category>OAuth</category><category>OpenID Connect</category></item></channel></rss>