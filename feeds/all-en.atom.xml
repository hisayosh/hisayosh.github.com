<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>hisayosh-&gt;blog</title><link href="http://hisayosh.github.io/" rel="alternate"></link><link href="http://hisayosh.github.io/feeds/all-en.atom.xml" rel="self"></link><id>http://hisayosh.github.io/</id><updated>2013-12-31T12:00:00+09:00</updated><entry><title>tsc_checker - 新208.5日問題簡易チェックツール</title><link href="http://hisayosh.github.io/posts/2013/12/tsc_checker/" rel="alternate"></link><updated>2013-12-31T12:00:00+09:00</updated><author><name>Hisayoshi Tamaki</name></author><id>tag:hisayosh.github.io,2013-12-31:posts/2013/12/tsc_checker/</id><summary type="html">&lt;p&gt;以前情報公開した&lt;a href="http://hisayosh.github.io/posts/2013/12/208days-problem/"&gt;新 208.5 日問題&lt;/a&gt;向けに、現在の TSC 値出力や numeric overflow 警告を行うツールを作成しました。  &lt;/p&gt;
&lt;p&gt;「今動いているサーバは大丈夫なのか？」という疑問を解決するためのツールです。GCC Inline Assembler を含め Linux Kernel 内の新 208.5 日問題ロジックとほぼ同等の処理を行います。&lt;a href="http://hisayosh.github.io/posts/2013/12/208days-problem/"&gt;記事&lt;/a&gt;にも書きましたが、&lt;strong&gt;本問題は旧 208.5 日問題とは異なり、 uptime 結果を確認することによって問題の有無を判断することが出来ません。再起動を行っても TSC 値がリセットされないことが問題の発生要因であるためです。ご注意ください。&lt;/strong&gt;&lt;a href="#1"&gt;*1&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;a href="https://github.com/hisayosh/tsc_checker"&gt;https://github.com/hisayosh/tsc_checker&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;従来のオペレーション（再起動）による TSC 値の蓄積状況を確認する&lt;/li&gt;
&lt;li&gt;仮の CPU クロック周波数を基に現在の numeric overflow の発生可能性を定量的に確認する&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;出力内容&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;現在の CPU 内の TSC 値&lt;/li&gt;
&lt;li&gt;引数で取得した CPU クロック周波数を元に算出した SC 値&lt;/li&gt;
&lt;li&gt;不具合を伴うロジックにより発生する pico sec order の 64 bit 変数値&lt;/li&gt;
&lt;li&gt;64 bit 変数の上限値&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;利用方法&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;tsc_checker の実行に必要な要素は、tsc_checker 実行環境の CPU クロック周波数のみです。以下の 2 ステップで実行します。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;1. tsc_checker 実行サーバの CPU クロック周波数の取得&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Intel Xeon E5 プロセッサーファミリーであれば、tsc_constant により TSC は CPU クロック周波数の動的変動の影響を受けません。コマンドラインから以下のコマンドを実行して該当 CPU の最大クロック周波数を取得します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;&lt;strong&gt;2. tsc_checker の実行&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;tsc_checkerを実行します。「-f」オプションの引数として「1.」で取得したクロック周波数を指定します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./tsc_checker -f 2794000
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;計算結果 : 通常時&lt;/strong&gt;&lt;a href="#2"&gt;*2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;TSC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1476354219900&lt;/span&gt;
&lt;span class="n"&gt;SC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;         &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;366&lt;/span&gt;
&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;    &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;540345644483400&lt;/span&gt;
&lt;span class="n"&gt;threashold&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;18446744073709551615&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;計算結果 : numeric overflow 発生時&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;TSC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;295504282125&lt;/span&gt;
&lt;span class="n"&gt;SC&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;         &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;366&lt;/span&gt;
&lt;span class="o"&gt;***&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="o"&gt;***&lt;/span&gt;
&lt;span class="n"&gt;there&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;possibility&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;numeric&lt;/span&gt; &lt;span class="n"&gt;overflow&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;startup&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;taken&lt;/span&gt; &lt;span class="n"&gt;measure&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;tsc_checker の仕組み&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;仕組みは単純です。まず、 TSC 値を Inline Assembler により取得します。具体的には、CPU に対し rdtsc ( read time stamp counter ) 命令を実行し、結果の上位 32 bit を EDX register、下位 32 bit を EAX register 経由で、それぞれ uint32_t 型の変数に格納します。そして「32 bit 左に shift した上位 bit 変数」と「下位 bit 変数」を OR 演算することで、uint64_t 型の変数にTSC 値を格納します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="nf"&gt;get_tsc&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;asm&lt;/span&gt; &lt;span class="k"&gt;volatile&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rdtsc&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;=a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;=d&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;次に、SC ( SCale ) の算出を行います。こちらも Linux Kernel と同一のロジックになっています。1000000 &lt;a href="#3"&gt;*3&lt;/a&gt; に対して 10 bit &lt;a href="#4"&gt;*4&lt;/a&gt; 分の左 shift を行った数値をキロヘルツ単位のクロック周波数で除算することで SC を算出します。最後行の tsc * scale が numeric overflow 発生原因となる演算です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;tsc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_tsc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000000&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tsc&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考までに、Linux Kernel では以下のマクロ演算で tsc * scale の計算を行うことにより numeric overflow の発生を抑止しています。tsc_checker の &lt;a href="https://github.com/hisayosh/tsc_checker/blob/master/tsc_checker.h"&gt;header file&lt;/a&gt; にマクロを追加していますので興味のある方はどうぞ。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* from linux kernel (/include/linux/kernel.h b/include/linux/kernel.h)&lt;/span&gt;
&lt;span class="cm"&gt; * Multiplies an integer by a fraction, while avoiding unnecessary&lt;/span&gt;
&lt;span class="cm"&gt; * overflow or loss of precision.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="cp"&gt;#define mult_frac(x, numer, denom)(                        \&lt;/span&gt;
&lt;span class="cp"&gt;{                                                          \&lt;/span&gt;
&lt;span class="cp"&gt;    typeof(x) quot = (x) / (denom);                        \&lt;/span&gt;
&lt;span class="cp"&gt;    typeof(x) rem  = (x) % (denom);                        \&lt;/span&gt;
&lt;span class="cp"&gt;    (quot * (numer)) + ((rem * (numer)) / (denom));        \&lt;/span&gt;
&lt;span class="cp"&gt;}                                                          \&lt;/span&gt;
&lt;span class="cp"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;tsc_checker 内でも以下のコードにより動作します。（91行目のコメントアウトを参照）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mult_frac&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1UL&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a name="1"&gt;&lt;/a&gt; *1 : はてブや Twitter で誤解されている方がいらっしゃったので念の為にフォローします&lt;br /&gt;
&lt;a name="2"&gt;&lt;/a&gt; *2 : TSC は常に増加し続けるため、本ツール実行時点で numeric overflow が発生しない場合も、その後の再起動時に問題が発生する可能性があります。あくまで TSC 蓄積値の確認や現在の演算結果の目安を確認するツールとしてご利用ください&lt;br /&gt;
&lt;a name="3"&gt;&lt;/a&gt; *3 : nano sec per micro sec 値&lt;br /&gt;
&lt;a name="4"&gt;&lt;/a&gt; *4 : scale factor 値&lt;/p&gt;</summary><category term="Linux"></category><category term="Tool"></category></entry><entry><title>新208.5日問題 - Systems with Intel® Xeon® Processor E5 hung after upgrade of Red Hat Enterprise Linux 6</title><link href="http://hisayosh.github.io/posts/2013/12/208days-problem/" rel="alternate"></link><updated>2013-12-24T12:25:00+09:00</updated><author><name>Hisayoshi Tamaki</name></author><id>tag:hisayosh.github.io,2013-12-24:posts/2013/12/208days-problem/</id><summary type="html">&lt;p&gt;Linux の連続稼働時間が 208.5 日を過ぎた段階で突如 Kernel Panic を引き起こすという過激な挙動で2011年の年の瀬に話題となった "旧208.5日問題" ですが、あれから二年が経った今、Linux Kernel 内の bug と Intel Xeon CPU の bug の合わせ技により&lt;strong&gt;再度類似の不具合が発生することが分かっています。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;旧 208.5 日問題の発生原理に関しては以下の blog が参考になります。&lt;br /&gt;
&lt;a href="http://kenichiokuyama.blogspot.jp/2011/12/schedclock-overflow-after-2085-days-in.html"&gt;okkyの銀河制圧奇譚 : sched_clock() overflow after 208.5 days in Linux Kernel&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;影響範囲&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;旧 208.5 日問題の対策パッチがあたっている Linux Kernel であっても、本 208.5 日問題は異なるロジックにより発生するため、&lt;strong&gt;影響を受けます。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red Hat Enterprise Linux 6.2, 6.3, and 6.4 (kernel 2.6.32-220, 2.6.32-279, and 2.6.32-358 series)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;不具合発生条件&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;Intel Xeon E5 シリーズのプロセッサーを利用している&lt;/li&gt;
&lt;li&gt;上記影響範囲に記述した Linux Kernel のうち、修正パッチが当たっていない（これらのバージョンのうち現在稼働中の RHEL 及び RHEL 系サーバはほとんどが該当すると思います。）&lt;/li&gt;
&lt;li&gt;最後に cold reboot を行ってから 208.5 日以上の時間が経過している状態で、再起動を行う&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;結論&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;不具合対象の環境は一時的な運用の見直しが必要です。サーバ再起動は cold reboot にしましょう&lt;/li&gt;
&lt;li&gt;根本解決には、対策パッチをあてるか、kernel code を修正してリビルドしたものを組み込みましょう&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;※ RHEL では kernel-2.6.32-220.45.1.el6 (6.2), kernel-2.6.32-279.37.2.el6 (6.3), kernel-2.6.32-358.23.2.el6 (6.4), kernel-2.6.32-431.el6 (6.5) で修正されているようです。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;旧 208.5 日問題のおさらい&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;旧 208.5 日問題は以下のインライン関数が原因となり発生します。CPU 内の TSC (Time Stamp Counter) の値を Linux が nano sec order の clock として利用するためのロジックです。CYCNS_SCALE_FACTOR は整数の 10 を表します。&lt;/p&gt;
&lt;p&gt;linux-2.6.32-220(/arch/x86/include/asm/timer.h)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;__cycles_2_ns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;cyc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;smp_processor_id&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;cyc&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ご覧の通り、TSC の値を TSC * SC &amp;gt;&amp;gt; 10 することで 64 bit 変数に nano sec を代入しようとしているので、10 bit shift が行われる前の段階では pico sec order の演算を行うことになります。pico sec order の 1 秒を表現するためには、約 40 bit の空間が必要となります。変数が 64 bit であるため、 1 秒以上の表現のためには残り約 24 bit 程しかなく、208.5日問題における 208.5 日とは、この約 24 bit で表現できる日数の上限を表したものになっています。（この日数を超えると overflow が発生します。）&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;新 208.5 日問題の解説&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Linux Kernel を起動する際、各種初期化処理を行う start_kernel()内 で x86_late_time_init() という関数が呼び出されます。&lt;/p&gt;
&lt;p&gt;linux-2.6.32.358(/arch/x86/kernel/time.c)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;x86_late_time_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;x86_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timer_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;tsc_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;このうち、tsc_init() の中で、cyc2ns_offset の初期化を行います。この初期化処理は、旧 208.5 日問題と同一のロジックを経由します。Linux の起動時には、 CPU の仕様として TSC がリセットされるはずであり、Linux 起動プロセスの初期段階である本関数がコールされる時点で TSC が 208.5 日に到達しているはずがなく、優先度の低い問題として扱われていたのだと思います。&lt;/p&gt;
&lt;p&gt;linux-2.6.32-358(/arch/x86/kernel/tsc.c)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set_cyc2ns_scale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;tsc_now&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ns_now&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;local_irq_save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;sched_clock_idle_sleep_event&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;per_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cyc2ns_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;rdtscll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc_now&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ns_now&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__cycles_2_ns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc_now&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSEC_PER_MSEC&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpu_khz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ns_now&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsc_now&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CYC2NS_SCALE_FACTOR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;sched_clock_idle_wakeup_event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;local_irq_restore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;しかし、時を同じくして、Intel Xeon Processor E5 Family は以下の不具合を抱えていました。本来リセットされるはずの TSC の値が、 Warm Reset (通常の再起動)時に初期化されないという不具合です。サーバの電源断を経由しない限り、 E5 Family Processor の TSC の値は保持され続けます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BT81. X X X No Fix TSC is Not Affected by Warm Reset&lt;br /&gt;
&lt;a href="http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-family-spec-update.pdf"&gt;Intel® Xeon® Processor E5 Family&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;つまり、新 208.5 日問題は、&lt;strong&gt;最後に電源停止を行ってから208.5日程度経過した段階で、再起動をした際に前述の初期化処理において offset 計算が overflow することで顕在化します。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;旧 208.5 日問題とは異なり、&lt;strong&gt;稼働中の OS では発生しませんが、再起動時に突然ハング状態になるため、対策パッチをあてるか、tsc.c &amp;amp; kernel.h を自前で修正してリビルドするか、運用プロセスを一時的に変更する必要があると思います。&lt;/strong&gt;kexec時も同様の問題が起きるはずですので、ご注意ください。&lt;/p&gt;
&lt;p&gt;記事に間違いや不明な点がありましたら、ご指摘下さい。&lt;/p&gt;
&lt;h3&gt;参考URL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://access.redhat.com/site/solutions/433883"&gt;Red Hat : Systems with Intel® Xeon® Processor E5 hung after upgrade of Red Hat Enterprise Linux 6&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://kernel.opensuse.org/cgit/kernel/commit/?id=9993bc635d01a6ee7f6b833b4ee65ce7c06350b1"&gt;OpenSUSE : sched/x86: Fix overflow in cyc2ns_offset&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Bug"></category></entry><entry><title>Identity Conferene 15</title><link href="http://hisayosh.github.io/posts/2013/02/idcon-15/" rel="alternate"></link><updated>2013-02-03T19:19:00+09:00</updated><author><name>Hisayoshi Tamaki</name></author><id>tag:hisayosh.github.io,2013-02-03:posts/2013/02/idcon-15/</id><summary type="html">&lt;p&gt;Identity Conference 15(#idcon) に参加してきました。&lt;br /&gt;
 非常に勉強になったので今後も参加できればなぁと思うと同時に&lt;br /&gt;
 SSO/IDM製品の開発に携わった経験がありながら初参加という状況で少し反省。  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://idcon.doorkeeper.jp/events/2448"&gt;#idcon 15th&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://togetter.com/li/448517"&gt;Togetther&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;Yahoo! JAPANのOAuth/OpenIDに代わる新しい認証認可機能 -YConnect-&lt;/h2&gt;
&lt;p&gt;ヤフー株式会社 河内 俊介 氏  &lt;/p&gt;
&lt;h3&gt;YConnectとは？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OAuth2.0準拠 / OpenID Connectをサポートの Yahoo!&lt;br /&gt;
    の新認証認可システム  &lt;/li&gt;
&lt;li&gt;Yahoo! でログインが可能  &lt;/li&gt;
&lt;li&gt;ユーザの一部属性情報の連携が可能  &lt;/li&gt;
&lt;li&gt;OAuth1.0 に比べて RP の実装が容易  &lt;/li&gt;
&lt;li&gt;2012年末　YConnect 設計開始  &lt;/li&gt;
&lt;li&gt;2012年9月中旬　パートナー向け公開開始  &lt;/li&gt;
&lt;li&gt;現在　公開中  &lt;/li&gt;
&lt;li&gt;対応Authorization Grant@OAuth2.0&lt;br /&gt;
     Authorization Code&lt;br /&gt;
     Implicit  &lt;/li&gt;
&lt;li&gt;対応Profile@OpenID Connect&lt;br /&gt;
     Basic Client Profile&lt;br /&gt;
     Implicit Client Profile  &lt;/li&gt;
&lt;li&gt;100サイト以上、50以上の企業に提供 毎日新聞社、GREE等等  &lt;/li&gt;
&lt;li&gt;社内アプリには続々対応中  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;用途の紹介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Yahooウォレットと連携することで決済システムを簡単に実装  &lt;/li&gt;
&lt;li&gt;属性情報の連携(ユーザ識別子、氏名、生年月日、ロケール情報、メールアドレス等等)&lt;br /&gt;
     プレミアム企業には更に多くの属性情報を開示している  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;導入構成図事例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Authorization Code 利用例  &lt;/li&gt;
&lt;li&gt;Implicit 利用例&lt;br /&gt;
     シーケンスの紹介  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;裏話&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OAuth1.0やBBAuthはYahoo!incのローカライズだった  &lt;/li&gt;
&lt;li&gt;ブラックボックスのため、メンテナンス工数が大変&lt;br /&gt;
     -&amp;gt; YConnectはフルスクラッチで開発することによりこの問題を解決  &lt;/li&gt;
&lt;li&gt;全WebAPIのSSL化を行う必要があった&lt;br /&gt;
     -&amp;gt; ワイルドカードの証明書で対応  &lt;/li&gt;
&lt;li&gt;仕様理解を深めるため、RFCの翻訳業務をPJで行った  &lt;/li&gt;
&lt;li&gt;Apple Store の reject 事例&lt;br /&gt;
    ブラウザを開いたタイミングでリンクがあると、課金の可能性を指定されrejectされた&lt;br /&gt;
     -&amp;gt; リンクを省くことで解決&lt;br /&gt;
     アプリケーションからsafariを使用してloginしたらrejectされた&lt;br /&gt;
    ログインしないと使えないようなアプリケーションはrejectされる可能性がある&lt;br /&gt;
     -&amp;gt; 解決策は見つかっていない  &lt;/li&gt;
&lt;li&gt;認証PF一覧&lt;br /&gt;
     用途によって認証PFが分散し、ユーザ識別子も分散していた&lt;br /&gt;
     　OAuth1.0 / Open ID2.0 / SSO 等  &lt;br /&gt;
     　-&amp;gt; YConnectでは上記全てを解決している  &lt;/li&gt;
&lt;li&gt;以下の機能拡張を検討中  &lt;br /&gt;
     PPID  &lt;br /&gt;
     OTP対応を検討中  &lt;br /&gt;
     シングルログアウト(Session Management)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q. カスタムURIスキーマが被ってしまった場合のセキュリティリスクは？  &lt;br /&gt;
 A. Yahoo!が提供しているアプリは他社のアプリと被らないようにしている。  &lt;br /&gt;
 攻撃者がいた場合、技術的には被らせることは可能。今後の課題として扱う。  &lt;/p&gt;
&lt;h2&gt;「Andouroid Android OSのカスタマイズによるアプリ間統合認証の実現」&lt;/h2&gt;
&lt;p&gt;ヤフー株式会社 安藤 義裕 氏  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android OS layor からアタッチ  &lt;/li&gt;
&lt;li&gt;個人(趣味)で開発  &lt;/li&gt;
&lt;li&gt;デモンストレーション&lt;br /&gt;
     Yahoo!のアプリ二種類を使い、一方のアプリにログインすると&lt;br /&gt;
     もう一方で認証が必要なくなる仕組みをデモ  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1. Yahoo!メールアプリの起動&lt;br /&gt;
 　　未ログイン状態&lt;br /&gt;
 　　アプリ終了&lt;br /&gt;
 　2. Yahoo!ブラウザの起動&lt;br /&gt;
 　　メールページを開く&lt;br /&gt;
 　　未ログイン状態  &lt;br /&gt;
 　　UID/PWD入力  &lt;br /&gt;
 　　ログイン成功、コンテンツ確認  &lt;br /&gt;
 　　アプリ終了&lt;br /&gt;
 　3. Yahoo!メールアプリの起動&lt;br /&gt;
 　　ログイン状態を維持(SSO成功)  &lt;/p&gt;
&lt;h3&gt;改修内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;WebKit(OSとアプリの中間レイヤー)の改造  &lt;/li&gt;
&lt;li&gt;ログイン画面を開く前にトークン(ストレージ)に問い合わせる仕組み  &lt;/li&gt;
&lt;li&gt;トークンはアプリケーション間で共有している  &lt;/li&gt;
&lt;li&gt;AndroidはアプリケーションごとにLinux UIDが割り当てられている  &lt;/li&gt;
&lt;li&gt;アプリが使用する Android 内の database file 等は上記の UID/GID&lt;br /&gt;
    により 660 の permission を付与し、 ACL を行っている  &lt;/li&gt;
&lt;li&gt;あんどうろいどは上記の database file&lt;br /&gt;
    に対し、独自user(yahoo)のアクセスを追加  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Androidのデータ共有の方法&lt;br /&gt;
     Content Provide&lt;br /&gt;
     　カレンダー、データ帳を他のアプリに提供&lt;br /&gt;
     Intent&lt;br /&gt;
     　アプリ間のデータのやりとり&lt;br /&gt;
     Shared Preference&lt;br /&gt;
     　テキスト等小さなデータを保存する。アプリ間の共有可能&lt;br /&gt;
     Shared ID  &lt;/p&gt;
&lt;p&gt;Play!Storeにuploadする際に、証明書を作成する。同じ証明書を使用していれば複数のapplicationで同じUIDを降ることができる    &lt;/p&gt;
&lt;p&gt;信頼できる大企業により同一の証明書を使用しアプリ間で情報連携を行うようにすれば、従来と異なるマーケットを開拓できるのでは&lt;br /&gt;
 その他(SQLite, Local File, Internet(Cloud))  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;デバイス時代のID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OSを握ってカスタマイズができる立場は非常に強力と感じている  &lt;/li&gt;
&lt;li&gt;Apple, Google&lt;br /&gt;
    をみてわかるように、OSベンダーであるからこそ出来ることは多い  &lt;/li&gt;
&lt;li&gt;やりたいこと、センシティブな情報の共有は、OSを握っているか否かで自由度がかなり変わる  &lt;/li&gt;
&lt;li&gt;デバイスの時代になると、デバイスのIDとWebのIDの境目は今後薄れていくと考えている  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q.　パッケージ名でYahoo!のアプリであることを判別している(模造可能、プロトタイプ版のため)&lt;br /&gt;
A.　アプリケーションにsignatureを付けることで正当性を確認する等の対応になると推測している  &lt;/p&gt;
&lt;p&gt;Q.　ストレージで何を共有していたか&lt;br /&gt;
A.　Cookie。本来はトークンになるべきところ。 &lt;/p&gt;
&lt;h2&gt;C向けサービスで2要素認証を普及させるためにできること&lt;/h2&gt;
&lt;p&gt;株式会社ミクシィ 伊東 諒 氏&lt;br /&gt;
&lt;a href="http://www.slideshare.net/ritou/idcon-15th-ritou-2factor-auth"&gt;Slide&lt;/a&gt;  &lt;/p&gt;
&lt;h3&gt;現状と課題&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C向けサービスにおける2要素認証の現状 &lt;/li&gt;
&lt;li&gt;金融系、ゲーム系などでは以前から普及 &lt;/li&gt;
&lt;li&gt;ユーザ数の多いサービスも実装  &lt;/li&gt;
&lt;li&gt;ワンタイムパスワードが実装方法として流行  &lt;/li&gt;
&lt;li&gt;ID/PWD認証 + αをオプションで提供  &lt;/li&gt;
&lt;li&gt;脆弱性や課題については黙認状態  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;普及への課題&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ついてこれないユーザー&lt;br /&gt;
     サービスごとの設定は面倒  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;導入しにくいプロトコルの存在&lt;br /&gt;
     POP/IMAP/SMTP, XMPP, … &lt;br /&gt;
     認証とリソースアクセスの強い結びつき  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解決策&lt;br /&gt;
     Yahoo! Google Facebook 等に OpenID Connect で Rely する&lt;br /&gt;
     信頼あるプロバイダの認証強度をそのまま利用できることがメリット  &lt;/p&gt;
&lt;p&gt;認証とリソースアクセスの強い結びつきに対し、アクセストークンを利用して分離することで対応  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenID Providerがやるべきこと&lt;br /&gt;
     認証強度の見える化&lt;br /&gt;
     　RPからみて、OPがどのような認証をするのかを把握できることが大切 
     対応する認証強度を開示&lt;br /&gt;
     認証したユーザの認証強度を提供&lt;br /&gt;
     求められる認証強度をRPに指定させる  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Relying Partyがやるべきこと&lt;br /&gt;
     自らのサービス・ユーザアクションに求められる認証強度を意識する 
     適切なタイミング、強度で再認証を要求する  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;残る課題&lt;br /&gt;
     2要素認証を採用しないOPはG&lt;br /&gt;
     1 USER per 1 OP の風潮&lt;br /&gt;
     -&amp;gt; ID/PW + αは組み合わせにくい?  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;追加認証に特化した認証プロバイダ&lt;br /&gt;
     RP側が既存OPとの組み合わせ&lt;br /&gt;
     Trustが重要&lt;br /&gt;
     　B向けに実績のあるサービスの進出&lt;br /&gt;
     物理デバイス、生体認証などの可能性  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;まとめ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最大の課題は”めんどくさい”と思わせるユーザビリティ  &lt;/li&gt;
&lt;li&gt;OpenID Connect は重要  &lt;/li&gt;
&lt;li&gt;経済合理性は別として追加認証に特化した認証プロバイダは有用かも  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;実際に追加認証に対応したプロバイダを作成してみた - SecondAuth -&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;メールアドレスがあれば登録可能  &lt;/li&gt;
&lt;li&gt;OTP 認証のみ実装  &lt;/li&gt;
&lt;li&gt;OpenID Connect OP  &lt;/li&gt;
&lt;li&gt;YConnect, Google, Faceboo  k
    から受け取った確認済みメールアドレスを利用  &lt;/li&gt;
&lt;li&gt;OTP 認証には Google Authenticator を利用(Server側の処理)  &lt;/li&gt;
&lt;li&gt;ユーザ単位に Secret 作成  &lt;/li&gt;
&lt;li&gt;設定用の QR コード生成  &lt;/li&gt;
&lt;li&gt;otpauth://totp/(mailaddress)  &lt;/li&gt;
&lt;li&gt;secret=(base43_encoded_otp_secret)  &lt;/li&gt;
&lt;li&gt;ユーザはアプリをインストールし、QRコードを読み取るだけ  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;リモートログアウト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;現在アクティブなセッションを一元管理  &lt;/li&gt;
&lt;li&gt;手元で別の端末をログアウト可能  &lt;/li&gt;
&lt;li&gt;Facebook, Googleが実装  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OpenID Connect Session Management&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OPのログアウトをRPから検知するための仕様  &lt;/li&gt;
&lt;li&gt;AuthZ Response にセッション識別子  &lt;/li&gt;
&lt;li&gt;iframe + postMessageを送り続ける  &lt;/li&gt;
&lt;li&gt;OPのログアウトをRPから検知し、他のRPのセッションも終わらせる等  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;#idcon mini のお知らせ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;もっと技術的な話をしたい人向けに #idcon mini を計画している &lt;/li&gt;
&lt;li&gt;少人数、USTなし  &lt;/li&gt;
&lt;li&gt;アンカンファレンスもどき  &lt;/li&gt;
&lt;li&gt;技術屋が気になることをじっくりと話せる場  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;パネルディスカッション「スマデバ時代ぼくらは幾つパスワードを使うのか 」※USTなし&lt;/h2&gt;
&lt;p&gt;ヤフー株式会社 セントラルサービスカンパニー 技術調査室 室長 楠 正憲 氏&lt;br /&gt;
 米国・OpenID Foundation 理事長 崎村 夏彦 氏&lt;br /&gt;
 セコム株式会社 IS研究所 松本 泰 氏&lt;br /&gt;
 OpenID Foundation Japan 事務局長代行 高橋 伸和 氏&lt;br /&gt;
 独立行政法人 情報処理推進機構 神田 雅透 氏  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;パスワードはどのくらい前からあるか&lt;br /&gt;
     1961年頃らしい。IBMのメインフレーム。&lt;br /&gt;
     一昨年がパスワード誕生50年  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSLが安全であるという土台の上に認証基盤を考えてきた&lt;br /&gt;
     2011年頃からきわどい状況になっている&lt;br /&gt;
     従来の認証基盤を維持していけるのかを考えていかないといけない時期  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL/PKIはなぜ危機に陥ったのか 　 本セッションに興味があれば、PKI DAY&lt;br /&gt;
    2012から資料を取得  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jnsa.org/seminar/pki-day/2012/data/PM01_kanda.pdf"&gt;サイバー攻撃ツールとしての公開鍵証明書の役割&lt;/a&gt;&lt;br /&gt;
 (個人的に必見の資料だと思います。)  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ネットの信頼性は技術、制度・運用、実装、ユーザリテラシの4点から担保されている  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ルートCAはPKIのTrust Anchor  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開鍵証明書が悪用されるのはどんなとき?&lt;br /&gt;
     ハッキングの問題&lt;br /&gt;
     　登録局の検証ミス&lt;br /&gt;
     　認証局への不正アクセス&lt;br /&gt;
     暗号技術の問題&lt;br /&gt;
     　計算量により秘密鍵を割り出す(公開鍵暗号の根本的な問題)  &lt;/p&gt;
&lt;p&gt;真正な公開鍵証明書と区別ができない不正な証明書を計算機により偽造(ハッシュ関数の問題)&lt;br /&gt;
 運用の問題&lt;br /&gt;
 　秘密鍵の流出&lt;br /&gt;
 　意図せず秘密鍵を共有  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DigiNotar のケース(PKIの危機を招いた事例)&lt;br /&gt;
     不正SSLサーバ証明書がCA機能を乗っ取られて発行 &lt;/p&gt;
&lt;p&gt;EV-SSLサーバ証明書発酵用CAを含め、少なくとも6つのCA(疑いを含めると30個以上のCA)に不正侵入され、不正SSLサーバ証明証を発行  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ルートCAとしてはあまりにも重大な失態が相次ぐ  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件報道されるまでの5週間、事実を隠蔽し続けた&lt;br /&gt;
     2011年6月17日攻撃が始まっていたことを把握  &lt;/p&gt;
&lt;p&gt;2011年7月19日以降、短期間に不正SSLサーバ証明書の発行・失効処理が繰り返されていたにも関わらず、根本的な対策を取らなかった&lt;br /&gt;
 2011年7月28日イランにおけるで不正SSLサーバ証明書の悪用を把握&lt;br /&gt;
 OSやブラウザベンダーにも通知をしなかった&lt;br /&gt;
-   主要ブラウザベンダーの対処&lt;br /&gt;
 DigiNotar のルート証明書を削除&lt;br /&gt;
-   DigiNotar は破産手続き開始&lt;br /&gt;
-   証明書を使うのを意識しないのはなぜ？&lt;br /&gt;
実際にはブラウザやアプリケーションが自動検証する&lt;br /&gt;
 登録されている「信頼できる認証局証明書」をベースに判定&lt;br /&gt;
 設定次第でリアルタイム検証も可能&lt;br /&gt;
 最もリテラシの低い人にあわせるとこうなってしまう、という典型  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以後オフレコ部分が多かったため、割愛します。&lt;br /&gt;
 記述内容の間違い等がありましたら指摘頂けますと助かります。&lt;/strong&gt;&lt;/p&gt;</summary><category term="OAuth"></category><category term="OpenID Connect"></category></entry></feed>